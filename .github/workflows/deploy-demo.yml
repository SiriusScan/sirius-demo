name: Deploy SiriusScan Demo

on:
  # Scheduled rebuilds (daily at 2 AM UTC)
  schedule:
    - cron: "0 2 * * *"

  # Manual trigger
  workflow_dispatch:
    inputs:
      skip_seeding:
        description: "Skip data seeding step"
        required: false
        default: false
        type: boolean
      force_rebuild:
        description: "Force full destroy/recreate even if instance is healthy"
        required: false
        default: false
        type: boolean
      image_tag:
        description: "GHCR image tag to deploy (default: latest)"
        required: false
        default: "latest"
        type: string

  # Trigger from main Sirius repository
  repository_dispatch:
    types: [sirius-demo-updated, sirius-main-updated]

  # Trigger on pushes to main branch
  push:
    branches: [main]

  # Terraform / infra validation on PRs
  pull_request:
    branches: [main]
    paths:
      - "infra/**"
      - "docker-compose.demo.yml"
      - ".github/workflows/deploy-demo.yml"

env:
  AWS_REGION: us-west-2
  TERRAFORM_DIR: infra/demo
  DEMO_INSTANCE_TYPE: t3.medium

jobs:
  # ── Decide: full rebuild vs fast update ──────────────────────────────────
  preflight:
    name: Preflight — check existing instance
    runs-on: ubuntu-latest
    outputs:
      instance_healthy: ${{ steps.check.outputs.instance_healthy }}
      instance_id: ${{ steps.check.outputs.instance_id }}
      public_ip: ${{ steps.check.outputs.public_ip }}
      strategy: ${{ steps.decide.outputs.strategy }}
      image_tag: ${{ steps.tag.outputs.image_tag }}

    permissions:
      id-token: write
      contents: read

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Determine image tag
        id: tag
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "image_tag=${{ github.event.inputs.image_tag || 'latest' }}" >> "$GITHUB_OUTPUT"
          else
            echo "image_tag=latest" >> "$GITHUB_OUTPUT"
          fi

      - name: Check existing demo instance health
        id: check
        run: |
          INSTANCE=$(aws ec2 describe-instances \
            --region "$AWS_REGION" \
            --filters "Name=tag:Project,Values=SiriusDemo" "Name=instance-state-name,Values=running" \
            --query 'Reservations[*].Instances[*].[InstanceId,PublicIpAddress]' \
            --output text | head -1)

          if [ -z "$INSTANCE" ]; then
            echo "instance_healthy=false" >> "$GITHUB_OUTPUT"
            echo "No running demo instance found"
            exit 0
          fi

          INSTANCE_ID=$(echo "$INSTANCE" | awk '{print $1}')
          PUBLIC_IP=$(echo "$INSTANCE" | awk '{print $2}')
          echo "instance_id=$INSTANCE_ID" >> "$GITHUB_OUTPUT"
          echo "public_ip=$PUBLIC_IP" >> "$GITHUB_OUTPUT"

          if curl -sf --max-time 10 "http://$PUBLIC_IP:9001/health" > /dev/null 2>&1; then
            echo "instance_healthy=true" >> "$GITHUB_OUTPUT"
            echo "Instance $INSTANCE_ID is healthy at $PUBLIC_IP"
          else
            echo "instance_healthy=false" >> "$GITHUB_OUTPUT"
            echo "Instance $INSTANCE_ID is NOT healthy"
          fi

      - name: Decide deployment strategy
        id: decide
        run: |
          FORCE="${{ github.event.inputs.force_rebuild }}"
          HEALTHY="${{ steps.check.outputs.instance_healthy }}"
          EVENT="${{ github.event_name }}"

          # Force rebuild requested
          if [ "$FORCE" = "true" ]; then
            echo "strategy=full" >> "$GITHUB_OUTPUT"
            echo "Strategy: full (force_rebuild=true)"
            exit 0
          fi

          # Scheduled runs always do a full deploy
          if [ "$EVENT" = "schedule" ]; then
            echo "strategy=full" >> "$GITHUB_OUTPUT"
            echo "Strategy: full (scheduled)"
            exit 0
          fi

          # If instance is healthy, do a fast update
          if [ "$HEALTHY" = "true" ]; then
            echo "strategy=fast" >> "$GITHUB_OUTPUT"
            echo "Strategy: fast (instance healthy)"
          else
            echo "strategy=full" >> "$GITHUB_OUTPUT"
            echo "Strategy: full (no healthy instance)"
          fi

  # ── Fast update: pull new images on existing instance ────────────────────
  fast-update:
    name: Fast Update (in-place image pull)
    runs-on: ubuntu-latest
    needs: preflight
    if: needs.preflight.outputs.strategy == 'fast'
    timeout-minutes: 10

    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Pull new images and restart via SSM
        id: update
        run: |
          INSTANCE_ID="${{ needs.preflight.outputs.instance_id }}"
          IMAGE_TAG="${{ needs.preflight.outputs.image_tag }}"

          echo "Sending update command to $INSTANCE_ID (tag: $IMAGE_TAG)..."

          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --timeout-seconds 300 \
            --parameters "commands=[
              \"cd /opt/sirius/demo\",
              \"sed -i 's/^IMAGE_TAG=.*/IMAGE_TAG=$IMAGE_TAG/' .env\",
              \"docker compose -f docker-compose.demo.yml pull\",
              \"docker compose -f docker-compose.demo.yml up -d --remove-orphans\",
              \"echo 'Update complete — waiting for API health...'\",
              \"timeout 120 bash -c 'until curl -sf http://localhost:9001/health > /dev/null; do sleep 5; done'\",
              \"docker compose -f docker-compose.demo.yml ps\"
            ]" \
            --region "$AWS_REGION" \
            --query "Command.CommandId" \
            --output text)

          echo "command_id=$COMMAND_ID" >> "$GITHUB_OUTPUT"
          echo "SSM command: $COMMAND_ID"

          # Wait for completion
          for i in $(seq 1 30); do
            STATUS=$(aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "$INSTANCE_ID" \
              --region "$AWS_REGION" \
              --query "Status" \
              --output text 2>/dev/null || echo "Pending")

            echo "  [$i/30] Status: $STATUS"

            if [ "$STATUS" = "Success" ]; then
              echo "Fast update succeeded"

              aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "$INSTANCE_ID" \
                --region "$AWS_REGION" \
                --query "StandardOutputContent" \
                --output text | tail -30

              exit 0
            elif [ "$STATUS" = "Failed" ] || [ "$STATUS" = "Cancelled" ] || [ "$STATUS" = "TimedOut" ]; then
              echo "Fast update failed ($STATUS)"

              aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "$INSTANCE_ID" \
                --region "$AWS_REGION" \
                --query "StandardErrorContent" \
                --output text | tail -30

              exit 1
            fi

            sleep 10
          done

          echo "Timed out waiting for SSM command"
          exit 1

      - name: Verify health after update
        run: |
          PUBLIC_IP="${{ needs.preflight.outputs.public_ip }}"

          for i in $(seq 1 12); do
            if curl -sf --max-time 10 "http://$PUBLIC_IP:9001/health" > /dev/null; then
              echo "API healthy"
              break
            fi
            echo "Waiting for API... ($i/12)"
            sleep 10
          done

          curl -sf "http://$PUBLIC_IP:9001/health" || { echo "API not healthy after update"; exit 1; }

          if curl -sf --max-time 10 -I "http://$PUBLIC_IP:3000" > /dev/null; then
            echo "UI healthy"
          else
            echo "UI not healthy after update"
            exit 1
          fi

          echo "Fast update verified — all services healthy"

  # ── Full deploy: terraform destroy + apply ───────────────────────────────
  full-deploy:
    name: Full Deploy (terraform destroy/apply)
    runs-on: ubuntu-latest
    needs: preflight
    if: needs.preflight.outputs.strategy == 'full'
    timeout-minutes: 30
    outputs:
      instance_id: ${{ steps.deploy.outputs.instance_id }}
      public_ip: ${{ steps.deploy.outputs.public_ip }}
      api_key: ${{ steps.deploy.outputs.api_key }}

    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.0

      - name: Terraform Init
        run: terraform -chdir=${{ env.TERRAFORM_DIR }} init

      - name: Terraform Validate
        run: terraform -chdir=${{ env.TERRAFORM_DIR }} validate -no-color

      - name: Destroy existing infrastructure
        run: |
          chmod +x scripts/cleanup-aws-resources.sh
          ./scripts/cleanup-aws-resources.sh
        continue-on-error: true

      - name: Wait for cleanup
        run: sleep 30

      - name: Deploy new infrastructure
        id: deploy
        run: |
          IMAGE_TAG="${{ needs.preflight.outputs.image_tag }}"

          terraform -chdir=${{ env.TERRAFORM_DIR }} init
          terraform -chdir=${{ env.TERRAFORM_DIR }} apply \
            -var="vpc_id=vpc-416eeb39" \
            -var="subnet_id=subnet-d31ffe8e" \
            -var="aws_region=us-west-2" \
            -var="instance_type=${{ env.DEMO_INSTANCE_TYPE }}" \
            -var="root_volume_size=30" \
            -var="image_tag=$IMAGE_TAG" \
            -var='public_key=${{ secrets.DEMO_SSH_PUBLIC_KEY }}' \
            -auto-approve

          INSTANCE_ID=$(terraform -chdir=${{ env.TERRAFORM_DIR }} output -raw instance_id)
          PUBLIC_IP=$(terraform -chdir=${{ env.TERRAFORM_DIR }} output -raw instance_public_ip)

          echo "instance_id=$INSTANCE_ID" >> "$GITHUB_OUTPUT"
          echo "public_ip=$PUBLIC_IP" >> "$GITHUB_OUTPUT"
          echo "ui_url=http://$PUBLIC_IP:3000" >> "$GITHUB_OUTPUT"
          echo "api_url=http://$PUBLIC_IP:9001" >> "$GITHUB_OUTPUT"

      - name: Wait for instance bootstrap
        run: sleep 60

      - name: Retrieve bootstrap logs
        if: always()
        run: |
          INSTANCE_ID="${{ steps.deploy.outputs.instance_id }}"
          aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --parameters 'commands=["tail -200 /var/log/sirius-bootstrap.log"]' \
            --region "$AWS_REGION" \
            --output text --query "Command.CommandId" > /tmp/cmd-id.txt 2>&1 || true

          sleep 10

          if [ -s /tmp/cmd-id.txt ]; then
            CMD_ID=$(head -1 /tmp/cmd-id.txt)
            if [ -n "$CMD_ID" ] && [ "$CMD_ID" != "None" ]; then
              aws ssm get-command-invocation \
                --command-id "$CMD_ID" \
                --instance-id "$INSTANCE_ID" \
                --region "$AWS_REGION" \
                --query "StandardOutputContent" \
                --output text 2>&1 | tail -100 || true
            fi
          fi

      - name: Health check
        id: health
        run: |
          PUBLIC_IP="${{ steps.deploy.outputs.public_ip }}"
          INSTANCE_ID="${{ steps.deploy.outputs.instance_id }}"

          for i in $(seq 1 60); do
            if curl -sf "http://$PUBLIC_IP:9001/health" > /dev/null; then
              echo "API is healthy"
              break
            fi
            echo "Waiting for API... ($i/60)"
            sleep 20
          done

          curl -sf "http://$PUBLIC_IP:9001/health" || { echo "API health check failed after 20 min"; exit 1; }

          if curl -sf -I "http://$PUBLIC_IP:3000" > /dev/null; then
            echo "UI is healthy"
          else
            echo "UI health check failed"
            exit 1
          fi

      - name: Retrieve API key from instance
        id: get_api_key
        if: steps.health.outcome == 'success'
        run: |
          INSTANCE_ID="${{ steps.deploy.outputs.instance_id }}"

          CMD_ID=$(aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --parameters 'commands=["grep ^SIRIUS_API_KEY= /opt/sirius/demo/.env | cut -d= -f2"]' \
            --region "$AWS_REGION" \
            --query "Command.CommandId" --output text)

          sleep 5

          API_KEY=$(aws ssm get-command-invocation \
            --command-id "$CMD_ID" \
            --instance-id "$INSTANCE_ID" \
            --region "$AWS_REGION" \
            --query "StandardOutputContent" --output text | tr -d '[:space:]')

          echo "::add-mask::$API_KEY"
          echo "api_key=$API_KEY" >> "$GITHUB_OUTPUT"

      - name: Update DNS
        if: steps.health.outcome == 'success'
        run: |
          chmod +x scripts/update-dns.sh
          ./scripts/update-dns.sh "${{ steps.deploy.outputs.public_ip }}" opensecurity.com sirius || echo "DNS update failed, continuing"

      - name: Seed demo data
        if: github.event.inputs.skip_seeding != 'true' && steps.health.outcome == 'success'
        run: |
          PUBLIC_IP="${{ steps.deploy.outputs.public_ip }}"
          API_KEY="${{ steps.get_api_key.outputs.api_key }}"

          sleep 30

          chmod +x scripts/seed_demo.sh
          ./scripts/seed_demo.sh "http://$PUBLIC_IP:9001" "$API_KEY" || echo "Data seeding failed, continuing"

      - name: Deployment summary
        if: always()
        run: |
          PUBLIC_IP="${{ steps.deploy.outputs.public_ip }}"
          INSTANCE_ID="${{ steps.deploy.outputs.instance_id }}"
          echo "===== Deployment Summary ====="
          echo "Instance ID: $INSTANCE_ID"
          echo "Public IP:   $PUBLIC_IP"
          echo "UI:  http://$PUBLIC_IP:3000"
          echo "API: http://$PUBLIC_IP:9001"
          echo "=============================="
